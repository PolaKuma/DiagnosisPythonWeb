{"remainingRequest":"/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/babel-loader/lib/index.js!/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src/main.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src/main.vue","mtime":1702053848267},{"path":"/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/babel.config.js","mtime":1700932419779},{"path":"/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/cache-loader/dist/cjs.js","mtime":1700932421620},{"path":"/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/babel-loader/lib/index.js","mtime":1700932421115},{"path":"/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/cache-loader/dist/cjs.js","mtime":1700932421620},{"path":"/Users/junjie/Documents/GitHub/Untitled/vue-admin-template/node_modules/vue-loader/lib/index.js","mtime":1700932427812}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9yZWdlbmVyYXRvclJ1bnRpbWUgZnJvbSAiL1VzZXJzL2p1bmppZS9Eb2N1bWVudHMvR2l0SHViL1VudGl0bGVkL3Z1ZS1hZG1pbi10ZW1wbGF0ZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcmVnZW5lcmF0b3JSdW50aW1lLmpzIjsKaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gIi9Vc2Vycy9qdW5qaWUvRG9jdW1lbnRzL0dpdEh1Yi9VbnRpdGxlZC92dWUtYWRtaW4tdGVtcGxhdGUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanMiOwppbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSAiL1VzZXJzL2p1bmppZS9Eb2N1bWVudHMvR2l0SHViL1VudGl0bGVkL3Z1ZS1hZG1pbi10ZW1wbGF0ZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiL1VzZXJzL2p1bmppZS9Eb2N1bWVudHMvR2l0SHViL1VudGl0bGVkL3Z1ZS1hZG1pbi10ZW1wbGF0ZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsbC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMiOwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwppbXBvcnQgeyB1dWlkIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9pbmRleCc7CmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gJ0BqaWFtaW5naGkvY2hhcnRzL2xpYi91dGlsL2luZGV4JzsKaW1wb3J0IHsgZGVlcENsb25lIH0gZnJvbSAnQGppYW1pbmdoaS9jLXJlbmRlci9saWIvcGx1Z2luL3V0aWwnOwppbXBvcnQgQ1JlbmRlciBmcm9tICdAamlhbWluZ2hpL2MtcmVuZGVyJzsKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdEdldhdGVyTGV2ZWxQb25kJywKICBwcm9wczogewogICAgY29uZmlnOiBPYmplY3QsCiAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHsKICAgICAgcmV0dXJuIHt9OwogICAgfQogIH0sCiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHsKICAgIHZhciBpZCA9IHV1aWQoKTsKICAgIHJldHVybiB7CiAgICAgIGdyYWRpZW50SWQ6ICJ3YXRlci1sZXZlbC1wb25kLSIuY29uY2F0KGlkKSwKICAgICAgZGVmYXVsdENvbmZpZzogewogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBEYXRhCiAgICAgICAgICogQHR5cGUge0FycmF5PE51bWJlcj59CiAgICAgICAgICogQGRlZmF1bHQgZGF0YSA9IFtdCiAgICAgICAgICogQGV4YW1wbGUgZGF0YSA9IFs2MCwgNDBdCiAgICAgICAgICovCiAgICAgICAgZGF0YTogW10sCgogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBTaGFwZSBvZiB3YW50ZXIgbGV2ZWwgcG9uZAogICAgICAgICAqIEB0eXBlIHtTdHJpbmd9CiAgICAgICAgICogQGRlZmF1bHQgc2hhcGUgPSAncmVjdCcKICAgICAgICAgKiBAZXhhbXBsZSBzaGFwZSA9ICdyZWN0JyB8ICdyb3VuZFJlY3QnIHwgJ3JvdW5kJwogICAgICAgICAqLwogICAgICAgIHNoYXBlOiAncmVjdCcsCgogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBXYXRlciB3YXZlIG51bWJlcgogICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9CiAgICAgICAgICogQGRlZmF1bHQgd2F2ZU51bSA9IDMKICAgICAgICAgKi8KICAgICAgICB3YXZlTnVtOiAzLAoKICAgICAgICAvKioKICAgICAgICAgKiBAZGVzY3JpcHRpb24gV2F0ZXIgd2F2ZSBoZWlnaHQgKHB4KQogICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9CiAgICAgICAgICogQGRlZmF1bHQgd2F2ZUhlaWdodCA9IDQwCiAgICAgICAgICovCiAgICAgICAgd2F2ZUhlaWdodDogNDAsCgogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBXYXZlIG9wYWNpdHkKICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfQogICAgICAgICAqIEBkZWZhdWx0IHdhdmVPcGFjaXR5ID0gMC40CiAgICAgICAgICovCiAgICAgICAgd2F2ZU9wYWNpdHk6IDAuNCwKCiAgICAgICAgLyoqCiAgICAgICAgICogQGRlc2NyaXB0aW9uIENvbG9ycyAoaGV4fHJnYnxyZ2JhfGNvbG9yIGtleXdvcmRzKQogICAgICAgICAqIEB0eXBlIHtBcnJheTxTdHJpbmc+fQogICAgICAgICAqIEBkZWZhdWx0IGNvbG9ycyA9IFsnIzAwQkFGRicsICcjM0RFN0M5J10KICAgICAgICAgKiBAZXhhbXBsZSBjb2xvcnMgPSBbJyMwMDAnLCAncmdiKDAsIDAsIDApJywgJ3JnYmEoMCwgMCwgMCwgMSknLCAncmVkJ10KICAgICAgICAgKi8KICAgICAgICBjb2xvcnM6IFsnIzNERTdDOScsICcjMDBCQUZGJ10sCgogICAgICAgIC8qKgogICAgICAgICAqIEBkZXNjcmlwdGlvbiBGb3JtYXR0ZXIKICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfQogICAgICAgICAqIEBkZWZhdWx0IGZvcm1hdHRlciA9ICd7dmFsdWV9JScKICAgICAgICAgKi8KICAgICAgICBmb3JtYXR0ZXI6ICd7dmFsdWV9JScKICAgICAgfSwKICAgICAgbWVyZ2VkQ29uZmlnOiB7fSwKICAgICAgcmVuZGVyZXI6IG51bGwsCiAgICAgIHN2Z0JvcmRlckdyYWRpZW50OiBbXSwKICAgICAgZGV0YWlsczogJycsCiAgICAgIHdhdmVzOiBbXSwKICAgICAgYW5pbWF0aW9uOiBmYWxzZQogICAgfTsKICB9LAogIGNvbXB1dGVkOiB7CiAgICByYWRpdXM6IGZ1bmN0aW9uIHJhZGl1cygpIHsKICAgICAgdmFyIHNoYXBlID0gdGhpcy5tZXJnZWRDb25maWcuc2hhcGU7CiAgICAgIGlmIChzaGFwZSA9PT0gJ3JvdW5kJykgcmV0dXJuICc1MCUnOwogICAgICBpZiAoc2hhcGUgPT09ICdyZWN0JykgcmV0dXJuICcwJzsKICAgICAgaWYgKHNoYXBlID09PSAncm91bmRSZWN0JykgcmV0dXJuICcxMHB4JzsKICAgICAgcmV0dXJuICcwJzsKICAgIH0sCiAgICBzaGFwZTogZnVuY3Rpb24gc2hhcGUoKSB7CiAgICAgIHZhciBzaGFwZSA9IHRoaXMubWVyZ2VkQ29uZmlnLnNoYXBlOwogICAgICBpZiAoIXNoYXBlKSByZXR1cm4gJ3JlY3QnOwogICAgICByZXR1cm4gc2hhcGU7CiAgICB9CiAgfSwKICB3YXRjaDogewogICAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoKSB7CiAgICAgIHZhciBjYWxjRGF0YSA9IHRoaXMuY2FsY0RhdGEsCiAgICAgICAgICByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7CiAgICAgIHJlbmRlcmVyLmRlbEFsbEdyYXBoKCk7CiAgICAgIHRoaXMud2F2ZXMgPSBbXTsKICAgICAgc2V0VGltZW91dChjYWxjRGF0YSwgMCk7CiAgICB9CiAgfSwKICBtZXRob2RzOiB7CiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkgewogICAgICB2YXIgaW5pdFJlbmRlciA9IHRoaXMuaW5pdFJlbmRlciwKICAgICAgICAgIGNvbmZpZyA9IHRoaXMuY29uZmlnLAogICAgICAgICAgY2FsY0RhdGEgPSB0aGlzLmNhbGNEYXRhOwogICAgICBpbml0UmVuZGVyKCk7CiAgICAgIGlmICghY29uZmlnKSByZXR1cm47CiAgICAgIGNhbGNEYXRhKCk7CiAgICB9LAogICAgaW5pdFJlbmRlcjogZnVuY3Rpb24gaW5pdFJlbmRlcigpIHsKICAgICAgdmFyICRyZWZzID0gdGhpcy4kcmVmczsKICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBDUmVuZGVyKCRyZWZzWyd3YXRlci1wb25kLWxldmVsJ10pOwogICAgfSwKICAgIGNhbGNEYXRhOiBmdW5jdGlvbiBjYWxjRGF0YSgpIHsKICAgICAgdmFyIG1lcmdlQ29uZmlnID0gdGhpcy5tZXJnZUNvbmZpZywKICAgICAgICAgIGNhbGNTdmdCb3JkZXJHcmFkaWVudCA9IHRoaXMuY2FsY1N2Z0JvcmRlckdyYWRpZW50LAogICAgICAgICAgY2FsY0RldGFpbHMgPSB0aGlzLmNhbGNEZXRhaWxzOwogICAgICBtZXJnZUNvbmZpZygpOwogICAgICBjYWxjU3ZnQm9yZGVyR3JhZGllbnQoKTsKICAgICAgY2FsY0RldGFpbHMoKTsKICAgICAgdmFyIGFkZFdhdmUgPSB0aGlzLmFkZFdhdmUsCiAgICAgICAgICBhbmltYXRpb25XYXZlID0gdGhpcy5hbmltYXRpb25XYXZlOwogICAgICBhZGRXYXZlKCk7CiAgICAgIGFuaW1hdGlvbldhdmUoKTsKICAgIH0sCiAgICBtZXJnZUNvbmZpZzogZnVuY3Rpb24gbWVyZ2VDb25maWcoKSB7CiAgICAgIHZhciBjb25maWcgPSB0aGlzLmNvbmZpZywKICAgICAgICAgIGRlZmF1bHRDb25maWcgPSB0aGlzLmRlZmF1bHRDb25maWc7CiAgICAgIHRoaXMubWVyZ2VkQ29uZmlnID0gZGVlcE1lcmdlKGRlZXBDbG9uZShkZWZhdWx0Q29uZmlnLCB0cnVlKSwgY29uZmlnKTsKICAgIH0sCiAgICBjYWxjU3ZnQm9yZGVyR3JhZGllbnQ6IGZ1bmN0aW9uIGNhbGNTdmdCb3JkZXJHcmFkaWVudCgpIHsKICAgICAgdmFyIGNvbG9ycyA9IHRoaXMubWVyZ2VkQ29uZmlnLmNvbG9yczsKICAgICAgdmFyIGNvbG9yTnVtID0gY29sb3JzLmxlbmd0aDsKICAgICAgdmFyIGNvbG9yT2Zmc2V0R2FwID0gMTAwIC8gKGNvbG9yTnVtIC0gMSk7CiAgICAgIHRoaXMuc3ZnQm9yZGVyR3JhZGllbnQgPSBjb2xvcnMubWFwKGZ1bmN0aW9uIChjLCBpKSB7CiAgICAgICAgcmV0dXJuIFtjb2xvck9mZnNldEdhcCAqIGksIGNdOwogICAgICB9KTsKICAgIH0sCiAgICBjYWxjRGV0YWlsczogZnVuY3Rpb24gY2FsY0RldGFpbHMoKSB7CiAgICAgIHZhciBfdGhpcyRtZXJnZWRDb25maWcgPSB0aGlzLm1lcmdlZENvbmZpZywKICAgICAgICAgIGRhdGEgPSBfdGhpcyRtZXJnZWRDb25maWcuZGF0YSwKICAgICAgICAgIGZvcm1hdHRlciA9IF90aGlzJG1lcmdlZENvbmZpZy5mb3JtYXR0ZXI7CgogICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7CiAgICAgICAgdGhpcy5kZXRhaWxzID0gJyc7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICB2YXIgbWF4VmFsdWUgPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoZGF0YSkpOwogICAgICB0aGlzLmRldGFpbHMgPSBmb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIG1heFZhbHVlKTsKICAgIH0sCiAgICBhZGRXYXZlOiBmdW5jdGlvbiBhZGRXYXZlKCkgewogICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyLAogICAgICAgICAgZ2V0V2F2ZVNoYXBlcyA9IHRoaXMuZ2V0V2F2ZVNoYXBlcywKICAgICAgICAgIGdldFdhdmVTdHlsZSA9IHRoaXMuZ2V0V2F2ZVN0eWxlLAogICAgICAgICAgZHJhd2VkID0gdGhpcy5kcmF3ZWQ7CiAgICAgIHZhciBzaGFwZXMgPSBnZXRXYXZlU2hhcGVzKCk7CiAgICAgIHZhciBzdHlsZSA9IGdldFdhdmVTdHlsZSgpOwogICAgICB0aGlzLndhdmVzID0gc2hhcGVzLm1hcChmdW5jdGlvbiAoc2hhcGUpIHsKICAgICAgICByZXR1cm4gcmVuZGVyZXIuYWRkKHsKICAgICAgICAgIG5hbWU6ICdzbW9vdGhsaW5lJywKICAgICAgICAgIGFuaW1hdGlvbkZyYW1lOiAzMDAsCiAgICAgICAgICBzaGFwZTogc2hhcGUsCiAgICAgICAgICBzdHlsZTogc3R5bGUsCiAgICAgICAgICBkcmF3ZWQ6IGRyYXdlZAogICAgICAgIH0pOwogICAgICB9KTsKICAgIH0sCiAgICBnZXRXYXZlU2hhcGVzOiBmdW5jdGlvbiBnZXRXYXZlU2hhcGVzKCkgewogICAgICB2YXIgbWVyZ2VkQ29uZmlnID0gdGhpcy5tZXJnZWRDb25maWcsCiAgICAgICAgICByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsCiAgICAgICAgICBtZXJnZU9mZnNldCA9IHRoaXMubWVyZ2VPZmZzZXQ7CiAgICAgIHZhciB3YXZlTnVtID0gbWVyZ2VkQ29uZmlnLndhdmVOdW0sCiAgICAgICAgICB3YXZlSGVpZ2h0ID0gbWVyZ2VkQ29uZmlnLndhdmVIZWlnaHQsCiAgICAgICAgICBkYXRhID0gbWVyZ2VkQ29uZmlnLmRhdGE7CgogICAgICB2YXIgX3JlbmRlcmVyJGFyZWEgPSBfc2xpY2VkVG9BcnJheShyZW5kZXJlci5hcmVhLCAyKSwKICAgICAgICAgIHcgPSBfcmVuZGVyZXIkYXJlYVswXSwKICAgICAgICAgIGggPSBfcmVuZGVyZXIkYXJlYVsxXTsKCiAgICAgIHZhciBwb2ludHNOdW0gPSB3YXZlTnVtICogNCArIDQ7CiAgICAgIHZhciBwb2ludFhHYXAgPSB3IC8gd2F2ZU51bSAvIDI7CiAgICAgIHJldHVybiBkYXRhLm1hcChmdW5jdGlvbiAodikgewogICAgICAgIHZhciBwb2ludHMgPSBuZXcgQXJyYXkocG9pbnRzTnVtKS5maWxsKDApLm1hcChmdW5jdGlvbiAoZm9vLCBqKSB7CiAgICAgICAgICB2YXIgeCA9IHcgLSBwb2ludFhHYXAgKiBqOwogICAgICAgICAgdmFyIHN0YXJ0WSA9ICgxIC0gdiAvIDEwMCkgKiBoOwogICAgICAgICAgdmFyIHkgPSBqICUgMiA9PT0gMCA/IHN0YXJ0WSA6IHN0YXJ0WSAtIHdhdmVIZWlnaHQ7CiAgICAgICAgICByZXR1cm4gW3gsIHldOwogICAgICAgIH0pOwogICAgICAgIHBvaW50cyA9IHBvaW50cy5tYXAoZnVuY3Rpb24gKHApIHsKICAgICAgICAgIHJldHVybiBtZXJnZU9mZnNldChwLCBbcG9pbnRYR2FwICogMiwgMF0pOwogICAgICAgIH0pOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwb2ludHM6IHBvaW50cwogICAgICAgIH07CiAgICAgIH0pOwogICAgfSwKICAgIG1lcmdlT2Zmc2V0OiBmdW5jdGlvbiBtZXJnZU9mZnNldChfcmVmLCBfcmVmMikgewogICAgICB2YXIgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSwKICAgICAgICAgIHggPSBfcmVmM1swXSwKICAgICAgICAgIHkgPSBfcmVmM1sxXTsKCiAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSwKICAgICAgICAgIG94ID0gX3JlZjRbMF0sCiAgICAgICAgICBveSA9IF9yZWY0WzFdOwoKICAgICAgcmV0dXJuIFt4ICsgb3gsIHkgKyBveV07CiAgICB9LAogICAgZ2V0V2F2ZVN0eWxlOiBmdW5jdGlvbiBnZXRXYXZlU3R5bGUoKSB7CiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsCiAgICAgICAgICBtZXJnZWRDb25maWcgPSB0aGlzLm1lcmdlZENvbmZpZzsKICAgICAgdmFyIGggPSByZW5kZXJlci5hcmVhWzFdOwogICAgICByZXR1cm4gewogICAgICAgIGdyYWRpZW50Q29sb3I6IG1lcmdlZENvbmZpZy5jb2xvcnMsCiAgICAgICAgZ3JhZGllbnRUeXBlOiAnbGluZWFyJywKICAgICAgICBncmFkaWVudFBhcmFtczogWzAsIDAsIDAsIGhdLAogICAgICAgIGdyYWRpZW50V2l0aDogJ2ZpbGwnLAogICAgICAgIG9wYWNpdHk6IG1lcmdlZENvbmZpZy53YXZlT3BhY2l0eSwKICAgICAgICB0cmFuc2xhdGU6IFswLCAwXQogICAgICB9OwogICAgfSwKICAgIGRyYXdlZDogZnVuY3Rpb24gZHJhd2VkKF9yZWY1LCBfcmVmNikgewogICAgICB2YXIgcG9pbnRzID0gX3JlZjUuc2hhcGUucG9pbnRzOwogICAgICB2YXIgY3R4ID0gX3JlZjYuY3R4LAogICAgICAgICAgYXJlYSA9IF9yZWY2LmFyZWE7CiAgICAgIHZhciBmaXJzdFBvaW50ID0gcG9pbnRzWzBdOwogICAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzLnNsaWNlKC0xKVswXTsKICAgICAgdmFyIGggPSBhcmVhWzFdOwogICAgICBjdHgubGluZVRvKGxhc3RQb2ludFswXSwgaCk7CiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludFswXSwgaCk7CiAgICAgIGN0eC5jbG9zZVBhdGgoKTsKICAgICAgY3R4LmZpbGwoKTsKICAgIH0sCiAgICBhbmltYXRpb25XYXZlOiBmdW5jdGlvbiBhbmltYXRpb25XYXZlKCkgewogICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cywKICAgICAgICAgIF90aGlzID0gdGhpczsKCiAgICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7CiAgICAgICAgdmFyIHJlcGVhdCwgd2F2ZXMsIHJlbmRlcmVyLCBhbmltYXRpb24sIHc7CiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7CiAgICAgICAgICB3aGlsZSAoMSkgewogICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7CiAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgcmVwZWF0ID0gX2FyZ3VtZW50cy5sZW5ndGggPiAwICYmIF9hcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IF9hcmd1bWVudHNbMF0gOiAxOwogICAgICAgICAgICAgICAgd2F2ZXMgPSBfdGhpcy53YXZlcywgcmVuZGVyZXIgPSBfdGhpcy5yZW5kZXJlciwgYW5pbWF0aW9uID0gX3RoaXMuYW5pbWF0aW9uOwoKICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uKSB7CiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0OwogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCJyZXR1cm4iKTsKCiAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uID0gdHJ1ZTsKICAgICAgICAgICAgICAgIHcgPSByZW5kZXJlci5hcmVhWzBdOwogICAgICAgICAgICAgICAgd2F2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZ3JhcGgpIHsKICAgICAgICAgICAgICAgICAgZ3JhcGguYXR0cignc3R5bGUnLCB7CiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiBbMCwgMF0KICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgIGdyYXBoLmFuaW1hdGlvbignc3R5bGUnLCB7CiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiBbdywgMF0KICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5OwogICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmxhdW5jaEFuaW1hdGlvbigpOwoKICAgICAgICAgICAgICBjYXNlIDk6CiAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRpb24gPSBmYWxzZTsKCiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIuZ3JhcGhzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7CiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoInJldHVybiIpOwoKICAgICAgICAgICAgICBjYXNlIDEyOgogICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uV2F2ZShyZXBlYXQgKyAxKTsKCiAgICAgICAgICAgICAgY2FzZSAxMzoKICAgICAgICAgICAgICBjYXNlICJlbmQiOgogICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0sIF9jYWxsZWUpOwogICAgICB9KSkoKTsKICAgIH0KICB9LAogIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7CiAgICB2YXIgaW5pdCA9IHRoaXMuaW5pdDsKICAgIGluaXQoKTsKICB9LAogIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7CiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyOwogICAgcmVuZGVyZXIuZGVsQWxsR3JhcGgoKTsKICAgIHRoaXMud2F2ZXMgPSBbXTsKICB9Cn07"},{"version":3,"mappings":"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","names":["name","props","config","default","data","gradientId","defaultConfig","shape","waveNum","waveHeight","waveOpacity","colors","formatter","mergedConfig","renderer","svgBorderGradient","details","waves","animation","computed","radius","watch","setTimeout","methods","init","initRender","calcData","mergeConfig","calcSvgBorderGradient","calcDetails","addWave","animationWave","animationFrame","style","drawed","getWaveShapes","points","mergeOffset","getWaveStyle","gradientColor","gradientType","gradientParams","gradientWith","opacity","translate","ctx","repeat","w","graph","mounted","beforeDestroy"],"sourceRoot":"node_modules/@jiaminghi/data-view/lib/components/waterLevelPond/src","sources":["main.vue"],"sourcesContent":["<template>\n  <div class=\"dv-water-pond-level\">\n    <svg v-if=\"renderer\">\n      <defs>\n        <linearGradient :id=\"gradientId\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n          <stop v-for=\"lc in svgBorderGradient\" :key=\"lc[0]\"\n            :offset=\"lc[0]\"\n            :stop-color=\"lc[1]\" />\n        </linearGradient>\n      </defs>\n\n      <text\n        v-if=\"renderer\"\n        :stroke=\"`url(#${gradientId})`\"\n        :fill=\"`url(#${gradientId})`\"\n        :x=\"renderer.area[0] / 2 + 8\"\n        :y=\"renderer.area[1] / 2 + 8\"\n      >\n        {{ details }}\n      </text>\n\n      <ellipse v-if=\"!shape || shape === 'round'\"\n        :cx=\"renderer.area[0] / 2 + 8\"\n        :cy=\"renderer.area[1] / 2 + 8\"\n        :rx=\"renderer.area[0] / 2 + 5\"\n        :ry=\"renderer.area[1] / 2 + 5\"\n        :stroke=\"`url(#${gradientId})`\" />\n\n      <rect v-else\n        x=\"2\" y=\"2\"\n        :rx=\"shape === 'roundRect' ? 10 : 0\"\n        :ry=\"shape === 'roundRect' ? 10 : 0\"\n        :width=\"renderer.area[0] + 12\"\n        :height=\"renderer.area[1] + 12\"\n        :stroke=\"`url(#${gradientId})`\" />\n    </svg>\n\n    <canvas ref=\"water-pond-level\" :style=\"`border-radius: ${radius};`\" />\n  </div>\n</template>\n\n<script>\nimport { uuid } from '../../../util/index'\n\nimport { deepMerge } from '@jiaminghi/charts/lib/util/index'\n\nimport { deepClone } from '@jiaminghi/c-render/lib/plugin/util'\n\nimport CRender from '@jiaminghi/c-render'\n\nexport default {\n  name: 'DvWaterLevelPond',\n  props: {\n    config: Object,\n    default: () => ({})\n  },\n  data () {\n    const id = uuid()\n    return {\n      gradientId: `water-level-pond-${id}`,\n\n      defaultConfig: {\n        /**\n         * @description Data\n         * @type {Array<Number>}\n         * @default data = []\n         * @example data = [60, 40]\n         */\n        data: [],\n        /**\n         * @description Shape of wanter level pond\n         * @type {String}\n         * @default shape = 'rect'\n         * @example shape = 'rect' | 'roundRect' | 'round'\n         */\n        shape: 'rect',\n        /**\n         * @description Water wave number\n         * @type {Number}\n         * @default waveNum = 3\n         */\n        waveNum: 3,\n        /**\n         * @description Water wave height (px)\n         * @type {Number}\n         * @default waveHeight = 40\n         */\n        waveHeight: 40,\n        /**\n         * @description Wave opacity\n         * @type {Number}\n         * @default waveOpacity = 0.4\n         */\n        waveOpacity: 0.4,\n        /**\n         * @description Colors (hex|rgb|rgba|color keywords)\n         * @type {Array<String>}\n         * @default colors = ['#00BAFF', '#3DE7C9']\n         * @example colors = ['#000', 'rgb(0, 0, 0)', 'rgba(0, 0, 0, 1)', 'red']\n         */\n        colors: ['#3DE7C9', '#00BAFF'],\n        /**\n         * @description Formatter\n         * @type {String}\n         * @default formatter = '{value}%'\n         */\n        formatter: '{value}%'\n      },\n\n      mergedConfig: {},\n\n      renderer: null,\n\n      svgBorderGradient: [],\n\n      details: '',\n\n      waves: [],\n\n      animation: false\n    }\n  },\n  computed: {\n    radius () {\n      const { shape } = this.mergedConfig\n\n      if (shape === 'round') return '50%'\n\n      if (shape === 'rect') return '0'\n\n      if (shape === 'roundRect') return '10px'\n\n      return '0'\n    },\n    shape () {\n      const { shape } = this.mergedConfig\n\n      if (!shape) return 'rect'\n\n      return shape\n    }\n  },\n  watch: {\n    config () {\n      const { calcData, renderer } = this\n\n      renderer.delAllGraph()\n\n      this.waves = []\n\n      setTimeout(calcData, 0)\n    }\n  },\n  methods: {\n    init () {\n      const { initRender, config, calcData } = this\n\n      initRender()\n\n      if (!config) return\n\n      calcData()\n    },\n    initRender () {\n      const { $refs } = this\n\n      this.renderer = new CRender($refs['water-pond-level'])\n    },\n    calcData () {\n      const { mergeConfig, calcSvgBorderGradient, calcDetails } = this\n\n      mergeConfig()\n\n      calcSvgBorderGradient()\n\n      calcDetails()\n\n      const { addWave, animationWave } = this\n\n      addWave()\n\n      animationWave()\n    },\n    mergeConfig () {\n      const { config, defaultConfig } = this\n\n      this.mergedConfig = deepMerge(deepClone(defaultConfig, true), config)\n    },\n    calcSvgBorderGradient () {\n      const { colors } = this.mergedConfig\n\n      const colorNum = colors.length\n\n      const colorOffsetGap = 100 / (colorNum - 1)\n\n      this.svgBorderGradient = colors.map((c, i) => [colorOffsetGap * i, c])\n    },\n    calcDetails () {\n      const { data, formatter } = this.mergedConfig\n\n      if (!data.length) {\n        this.details = ''\n\n        return\n      }\n\n      const maxValue = Math.max(...data)\n\n      this.details = formatter.replace('{value}', maxValue)\n    },\n    addWave () {\n      const { renderer, getWaveShapes, getWaveStyle, drawed } = this\n\n      const shapes = getWaveShapes()\n      const style = getWaveStyle()\n\n      this.waves = shapes.map(shape => renderer.add({\n        name: 'smoothline',\n        animationFrame: 300,\n        shape,\n        style,\n        drawed\n      }))\n    },\n    getWaveShapes () {\n      const { mergedConfig, renderer, mergeOffset } = this\n\n      const { waveNum, waveHeight, data } = mergedConfig\n\n      const [w, h] = renderer.area\n\n      const pointsNum = waveNum * 4 + 4\n\n      const pointXGap = w / waveNum / 2\n\n      return data.map(v => {\n        let points = new Array(pointsNum).fill(0).map((foo, j) => {\n          const x = w - pointXGap * j\n\n          const startY = (1 - v / 100) * h\n\n          const y = j % 2 === 0 ? startY : startY - waveHeight\n\n          return [x, y]\n        })\n\n        points = points.map(p => mergeOffset(p, [pointXGap * 2, 0]))\n\n        return { points }\n      })\n    },\n    mergeOffset ([x, y], [ox, oy]) {\n      return [x + ox, y + oy]\n    },\n    getWaveStyle () {\n      const { renderer, mergedConfig } = this\n\n      const h = renderer.area[1]\n\n      return {\n        gradientColor: mergedConfig.colors,\n        gradientType: 'linear',\n        gradientParams: [0, 0, 0, h],\n        gradientWith: 'fill',\n        opacity: mergedConfig.waveOpacity,\n        translate: [0, 0]\n      }\n    },\n    drawed ({ shape: { points } }, { ctx, area }) {\n      const firstPoint = points[0]\n      const lastPoint = points.slice(-1)[0]\n\n      const h = area[1]\n\n      ctx.lineTo(lastPoint[0], h)\n      ctx.lineTo(firstPoint[0], h)\n\n      ctx.closePath()\n\n      ctx.fill()\n    },\n    async animationWave (repeat = 1) {\n      const { waves, renderer, animation } = this\n\n      if (animation) return\n\n      this.animation = true\n\n      const w = renderer.area[0]\n\n      waves.forEach(graph => {\n        graph.attr('style', { translate: [0, 0] })\n\n        graph.animation('style', {\n          translate: [w, 0]\n        }, true)\n      })\n\n      await renderer.launchAnimation()\n\n      this.animation = false\n\n      if (!renderer.graphs.length) return\n\n      this.animationWave(repeat + 1)\n    }\n  },\n  mounted () {\n    const { init } = this\n\n    init()\n  },\n  beforeDestroy () {\n    const { renderer } = this\n\n    renderer.delAllGraph()\n\n    this.waves = []\n  }\n}\n</script>"]}]}